# ü§ñ PROMPTS ESTRUTURADOS PARA ANTIGRAVITY + GEMINI 3.0
## Transformar HoraProfe em SaaS com IA

---

## üìå CONTEXTO PARA O GEMINI

Cole isto ANTES de cada prompt no Antigravity:

```
Voc√™ √© um especialista em desenvolvimento full-stack. Estou usando Antigravity com Gemini 3.0 para criar um SaaS educacional chamado HoraProfe.

TECNOLOGIAS:
- Frontend: React + TypeScript
- Backend: Node.js + Express
- Database: PostgreSQL
- Autentica√ß√£o: Auth0 ou Supabase Auth
- Pagamento: Stripe API
- Email: SendGrid API

ARQUITETURA:
- Multi-tenancy (cada col√©gio tem seus dados isolados)
- JWT com tenant_id nos claims
- Row-level isolation no banco
- Suporte a 3 roles: admin, coordenador, professor

OBJETIVO: MVP SaaS pronto para closed beta em 4 semanas, focado em col√©gios.

Gere c√≥digo production-ready com:
‚úì Tratamento de erros
‚úì Valida√ß√£o de inputs
‚úì Security (CORS, rate limiting, SQL injection prevention)
‚úì Testes b√°sicos (se aplic√°vel)
‚úì Coment√°rios explicativos

Estruture o c√≥digo em componentes/modules reutiliz√°veis.
```

---

## üéØ FASE 1: AUTENTICA√á√ÉO + MULTI-TENANCY (Semana 1)

### PROMPT 1: Setup Auth0 Integration

```
Crie um m√≥dulo de autentica√ß√£o com Auth0 para uma aplica√ß√£o React + Express.

REQUISITOS:
1. Frontend (React):
   - Hook useAuth() que retorna: { user, isLoading, login(), logout(), isAuthenticated }
   - P√°gina de login com redirect de callback
   - Prote√ß√£o de rotas (PrivateRoute component)
   - Armazenar Access Token + Refresh Token
   - Interceptador Axios que adiciona Authorization header

2. Backend (Express):
   - Middleware auth.js que valida JWT
   - Extrair tenant_id do token (custom claim no Auth0)
   - Endpoint POST /auth/callback que cria usu√°rio no BD se n√£o existir
   - Endpoint POST /auth/logout
   - Valida√ß√£o de token expirado com refresh

3. Auth0 Config:
   - Custom claim "tenant_id" (namespace: https://horaprofe.com.br/tenant_id)
   - Rules do Auth0 que adicionam tenant_id ao token

Gere c√≥digo completo, pronto para usar.
```

### PROMPT 2: Multi-Tenancy Database Schema

```
Crie schema PostgreSQL para multi-tenancy com isolamento total de dados.

REQUISITOS:
1. Tabelas:
   - organizations (col√©gios)
   - users
   - organization_members (rela√ß√£o many-to-many com roles)
   - schedules (grades hor√°rias)
   - invoices (faturas)
   - audit_logs (conformidade)

2. Seguran√ßa:
   - Foreign key references com ON DELETE CASCADE
   - RLS (Row Level Security) policies
   - √çndices em tenant_id para performance
   - Constraints de unicidade apropriados

3. Campos importantes:
   - organizations: name, slug, stripe_customer_id, plan_id, plan_active_until, timezone, created_at
   - users: email, name, auth0_id, email_verified, created_at
   - organization_members: role ENUM (admin, coordenador, professor)
   - schedules: organization_id, status, created_by, generated_at
   - invoices: stripe_invoice_id, amount_cents, status, paid_at

Gere migrations do Knex.js ou SQL puro com coment√°rios explicando cada tabela.
```

### PROMPT 3: Middleware de Isolamento de Tenant

```
Crie middleware Express que garante isolamento total de tenant em cada requisi√ß√£o.

REQUISITOS:
1. Middleware (tenantMiddleware.js):
   - Extrair tenant_id do JWT
   - Validar que tenant_id existe e √© v√°lido
   - Adicionar tenant_id ao objeto request (req.tenant)
   - Bloquear requests sem tenant_id v√°lido (403)
   - Rate limiting por tenant (100 requests/minuto)

2. Query Helper:
   - Fun√ß√£o withTenant(query) que auto-adiciona WHERE organization_id = tenant_id
   - Prevenir SQL injection
   - Exemplo: withTenant(db('schedules')) retorna query segura

3. Error Handling:
   - TenantNotFoundError (404)
   - UnauthorizedTenantError (403)
   - Logger estruturado com tenant_id

Gere middleware completo com tratamento de edge cases.
```

---

## üí≥ FASE 2: SISTEMA DE PAGAMENTO STRIPE (Semana 1-2)

### PROMPT 4: Integra√ß√£o Stripe - Backend

```
Crie backend endpoints para Stripe integration com webhook handling.

REQUISITOS:
1. Endpoints:
   - POST /billing/plans (retorna planos: freemium, pro, enterprise)
   - POST /billing/checkout-session (cria sess√£o Stripe Checkout)
   - POST /billing/webhook (processa eventos Stripe)
   - GET /billing/invoices (lista faturas do tenant)
   - POST /billing/cancel-subscription (cancelar plano)

2. Webhook Events a Processar:
   - customer.subscription.created ‚Üí Ativar plano no BD
   - customer.subscription.updated ‚Üí Ajustar limites
   - invoice.payment_succeeded ‚Üí Registrar pagamento
   - invoice.payment_failed ‚Üí Avisar via email
   - customer.subscription.deleted ‚Üí Downgrade autom√°tico

3. Database Operations:
   - Salvar stripe_customer_id na organization
   - Registrar invoice em invoices table
   - Atualizar plan_id e plan_active_until
   - Log em audit_logs

4. Seguran√ßa:
   - Validar webhook signature do Stripe
   - Processar webhook idempotente (evitar duplica√ß√£o)
   - Encriptar dados sens√≠veis

Gere c√≥digo production-ready com tratamento de erros robusto.
```

### PROMPT 5: Integra√ß√£o Stripe - Frontend

```
Crie componentes React para checkout e gerenciamento de billing.

REQUISITOS:
1. P√°gina de Planos (/pricing):
   - Card component para cada plano (Freemium, Pro, Enterprise)
   - Descri√ß√£o de features por plano
   - Bot√£o "Escolher Plano" com handler
   - Redirecionar para Stripe Checkout via API

2. Dashboard Billing (/account/billing):
   - Exibir plano atual ativo
   - Status: "Ativo at√© [data]"
   - Bot√£o "Upgrade" ou "Downgrade"
   - Lista de faturas com links para download PDF
   - Bot√£o "Cancelar Assinatura" com confirma√ß√£o

3. Upgrade Modal:
   - Mostrar quando user atinge limite (ex: 2¬™ grade no Freemium)
   - CTA claro: "Upgrade para Pro"
   - Link para pricing page

4. Estados de Carregamento:
   - Loading na cria√ß√£o de checkout
   - Success message ap√≥s pagamento
   - Error handling com notifica√ß√£o

Gere componentes com Tailwind CSS, reutiliz√°veis e acess√≠veis.
```

### PROMPT 6: Email Transacionais com SendGrid

```
Crie sistema de email templates com SendGrid API.

REQUISITOS:
1. Email Templates (criar no SendGrid antes):
   - welcome.html (bem-vindo ap√≥s verificar email)
   - verify-email.html (link de verifica√ß√£o)
   - password-reset.html (link para resetar senha)
   - payment-confirmed.html (confirma√ß√£o de pagamento)
   - invoice.html (recibo com link para PDF)
   - new-schedule-ready.html (grade foi gerada)
   - trial-ending-soon.html (aviso 3 dias antes de expirar)

2. Service (emailService.js):
   - sendWelcomeEmail(user, organization)
   - sendVerificationEmail(email, token)
   - sendPasswordResetEmail(email, token)
   - sendPaymentConfirmed(organization, invoice)
   - sendScheduleReady(organization, schedule)
   - sendTrialEndingAlert(organization)

3. Funcionalidades:
   - Vari√°veis de template ({{user_name}}, {{org_name}}, etc)
   - Links com tracking
   - Retry autom√°tico se falhar
   - Log em DB cada envio (para compliance)
   - Unsubscribe link

4. Integra√ß√£o:
   - Chamar emailService ap√≥s eventos de sucesso (pagamento, grade gerada, etc)
   - Async/await para n√£o bloquear requisi√ß√£o
   - Fila de emails (Bull queue) se volume crescer

Gere c√≥digo que se integra com Stripe webhook e endpoints cr√≠ticos.
```

---

## üìä FASE 3: DASHBOARD + GEST√ÉO DE USU√ÅRIOS (Semana 2)

### PROMPT 7: Dashboard Admin B√°sico

```
Crie dashboard admin para gerenciar organiza√ß√£o e subscriptions.

REQUISITOS:
1. Layout:
   - Sidebar com navega√ß√£o (Home, Grades, Usu√°rios, Billing, Settings)
   - Header com user dropdown + notifica√ß√µes
   - Cards informativos: Plano atual, Status, Limite de grades

2. Home Dashboard:
   - Card "Plano Ativo": nome, data de expira√ß√£o, bot√£o upgrade
   - Card "Uso": X grades criadas de Y permitidas
   - Card "√öltimas Faturas": lista com status (pago, pendente, vencido)
   - Link r√°pido "Gerar Nova Grade"
   - Aviso se trial est√° acabando (em vermelho)

3. P√°gina /account/settings:
   - Editar nome da organiza√ß√£o
   - Upload logo
   - Timezone selector
   - CNPJ (opcional)
   - Bot√£o "Excluir Organiza√ß√£o" com confirma√ß√£o dupla

4. P√°gina /account/users:
   - Lista de membros com role
   - Bot√£o "+ Convidar Usu√°rio" (email input)
   - Tabela: Nome | Email | Role | A√ß√µes (editar, remover)
   - Modal para editar role (admin/coordenador/professor)
   - Confirma√ß√£o antes de remover user

5. Responsivo:
   - Mobile-first design
   - Sidebar colaps√°vel em mobile

Gere com React Components, TypeScript, Tailwind CSS.
```

### PROMPT 8: Sistema de Convites de Usu√°rios

```
Crie fluxo de convite e onboarding de usu√°rios para organiza√ß√£o.

REQUISITOS:
1. Fluxo:
   - Admin clica "Convidar Usu√°rio"
   - Input de email + sele√ß√£o de role
   - Sistema gera link √∫nico de convite v√°lido 7 dias
   - Email enviado com link: /invite?token=xyz
   - Convidado clica ‚Üí Cria conta ou faz login se existir
   - Auto-adiciona √† organiza√ß√£o com role especificada

2. Backend:
   - Tabela invitations (email, token, role, organization_id, created_at, expires_at, accepted_at)
   - Endpoint POST /organizations/:id/invite
   - Endpoint GET /invitations/:token (validar token)
   - Endpoint POST /invitations/:token/accept (aceitar convite)
   - Endpoint DELETE /invitations/:id (revogar)

3. Security:
   - Token √© UUID √∫nico, criptografado no BD
   - Validar se token expirou
   - Validar se email j√° existe na organiza√ß√£o
   - Rate limiting em invites (max 50/dia por org)

4. Email:
   - Template invite.html com bot√£o "Aceitar Convite"
   - Link de convite direto no email

Gere c√≥digo completo com testes.
```

---

## üìã FASE 4: GERADOR DE GRADES (UPGRADE) (Semana 2-3)

### PROMPT 9: API de Gera√ß√£o de Grades com IA

```
Crie endpoints para gerar grades hor√°rias usando algoritmo de satisfa√ß√£o de restri√ß√µes.

REQUISITOS:
1. Endpoint POST /schedules/generate:
   Input:
   {
     "name": "1¬∫ Semestre 2025",
     "periods": 6,  // quantos per√≠odos por dia
     "days": ["seg", "ter", "qua", "qui", "sex"],
     "teachers": [{ id, name, disponibility: [[seg, per1], [seg, per2], ...] }],
     "classes": [{ id, year, name, subjects: [{ name, teacher_id, hours_per_week }] }],
     "classrooms": [{ id, name, capacity }],
     "preferences": { min_gaps: true, group_labs: true }
   }

2. Processamento:
   - Validar inputs (nenhuma classe sem professor, etc)
   - Usar constraint satisfaction algorithm (simulated annealing ou genetic algorithm)
   - Respeitar restri√ß√µes: professor n√£o em 2 lugares, gap m√≠nimo, etc
   - Gerar m√∫ltiplas solu√ß√µes (top 3 melhores)
   - Calcular score de qualidade (0-100)

3. Output:
   {
     "solutions": [
       {
         "score": 95,
         "schedule": [
           { day: "seg", period: 1, class_id: "1A", subject: "portugu√™s", teacher_id: "t1", classroom_id: "101" },
           ...
         ]
       }
     ],
     "generation_time": 2.5  // segundos
   }

4. Database:
   - Salvar schedule com status "draft"
   - Salvar cada solu√ß√£o (schedule_solutions table)
   - User pode escolher qual solu√ß√£o, salvando como "published"

5. Performance:
   - Gerar em < 30s para grades t√≠picas
   - Se demorar > 30s, retornar solu√ß√£o parcial + aviso

Gere algoritmo com explica√ß√µes de como funciona.
```

### PROMPT 10: Exportar Grade em PDF/Excel/ICS

```
Crie endpoints para exportar grades em m√∫ltiplos formatos.

REQUISITOS:
1. Endpoint GET /schedules/:id/export?format=pdf|excel|ics

2. Formato PDF:
   - Usar library: PDFKit ou pdfmake
   - Tabela hor√°ria com professores, turmas, salas
   - Cor por classe (automaticamente)
   - Header com nome da escola + per√≠odo
   - Rodap√© com data de gera√ß√£o
   - Pronto para imprimir A3/A4

3. Formato Excel:
   - Usar library: ExcelJS
   - Sheet por turma
   - Cada c√©lula: disciplina | professor
   - Formata√ß√£o com cores
   - Baixar como .xlsx

4. Formato ICS (iCalendar):
   - Usar library: ics.js
   - Cada aula como evento
   - Import√°vel em Google Calendar, Outlook
   - Recorr√™ncia: segunda-feira √†s 07:00 (exemplo)
   - Descri√ß√£o: turma, professor, sala

5. Email com Anexo:
   - Ap√≥s gerar grade, enviar PDF por email ao coordenador
   - File armazenado em AWS S3 (opcional) ou endpoint de download

Gere c√≥digo com tratamento de erros e compression de files.
```

---

## üîê FASE 5: SEGURAN√áA + DEPLOYMENT (Semana 3-4)

### PROMPT 11: Security Hardening

```
Crie checklist de seguran√ßa e implemente prote√ß√µes essenciais.

REQUISITOS:
1. CORS:
   - Apenas dom√≠nios confi√°veis (app.horaprofe.com.br, localhost:3000)
   - Permitir credenciais (credentials: true)

2. Rate Limiting:
   - 100 requests/minuto por IP
   - 50 requests/minuto para login
   - 10 generate-schedule/minuto por tenant

3. Helmet.js:
   - Adicionar headers de seguran√ßa (CSP, X-Frame-Options, etc)
   - Proteger contra clickjacking, XSS

4. Input Validation:
   - Usar Joi ou Zod para validar todas as inputs
   - Sanitizar strings (escape HTML)
   - Validar email, URLs, etc

5. SQL Injection Prevention:
   - Usar prepared statements em todas queries
   - Nunca concatenar strings em SQL

6. Database Backups:
   - Setup backup autom√°tico di√°rio
   - Teste restore de backup

7. Secrets Management:
   - Nunca commitar .env no git
   - Usar environment variables

Gere middleware de seguran√ßa que pode ser plugado em Express.
```

### PROMPT 12: Setup Vercel (Frontend) + Railway (Backend)

```
Crie guia de deploy autom√°tico para Vercel + Railway.

REQUISITOS:
1. Vercel Setup (Frontend React):
   - Conectar repo GitHub
   - Vari√°veis de ambiente: REACT_APP_AUTH0_DOMAIN, REACT_APP_API_URL, etc
   - Deploy autom√°tico em cada push para main
   - Preview deploys para PRs
   - Custom domain: app.horaprofe.com.br

2. Railway Setup (Backend Node.js):
   - Conectar repo GitHub
   - Vari√°veis de ambiente: DATABASE_URL, STRIPE_SECRET_KEY, etc
   - Build command: npm ci && npm run build
   - Start command: npm start
   - Deploy autom√°tico em cada push
   - Custom domain: api.horaprofe.com.br

3. Database (PostgreSQL na Railway):
   - Criar banco PostgreSQL
   - Backup autom√°tico habilitado
   - Connection pool setup

4. Monitoramento:
   - Sentry para error tracking
   - Logs estruturados com Winston
   - Alertas via email/Slack

Gere documenta√ß√£o passo-a-passo com screenshots.
```

---

## ‚úÖ ORDEM DE EXECU√á√ÉO (4 SEMANAS)

### Semana 1
- ‚úÖ Prompt 1: Auth0 integration
- ‚úÖ Prompt 2: Database schema
- ‚úÖ Prompt 3: Tenant middleware
- ‚úÖ Prompt 4: Stripe backend
- ‚úÖ Teste local: criar conta ‚Üí fazer login ‚Üí ver dashboard

### Semana 2
- ‚úÖ Prompt 5: Stripe frontend
- ‚úÖ Prompt 6: SendGrid emails
- ‚úÖ Prompt 7: Dashboard admin
- ‚úÖ Prompt 8: Convite de usu√°rios
- ‚úÖ Teste local: upgrade freemium ‚Üí pro, receber email

### Semana 3
- ‚úÖ Prompt 9: Algoritmo de gera√ß√£o de grades
- ‚úÖ Prompt 10: Export PDF/Excel/ICS
- ‚úÖ Teste local: gerar grade ‚Üí exportar ‚Üí receber email com anexo

### Semana 4
- ‚úÖ Prompt 11: Security hardening
- ‚úÖ Prompt 12: Deploy Vercel + Railway
- ‚úÖ Teste em staging com 3 col√©gios piloto
- ‚úÖ Ajustes finais baseado em feedback
- ‚úÖ Launch beta privado

---

## üéì DICAS PARA USAR ANTIGRAVITY EFICIENTEMENTE

1. **Cole o contexto UMA VEZ** no in√≠cio de cada sess√£o
2. **Use um prompt por feature** (n√£o pedir tudo junto)
3. **Pe√ßa para gerar com testes**: "Inclua testes unit√°rios com Jest"
4. **Pe√ßa c√≥digo em arquivos separados**: "Separe em /controllers, /services, /middlewares"
5. **Revise o c√≥digo gerado** antes de commitar (IA √†s vezes gera l√≥gica redundante)
6. **Teste incrementalmente** depois de cada prompt
7. **Documente o que funcionou** para refer√™ncia futura
8. **Se algo n√£o funcionar**, seja espec√≠fico no feedback: "Erro: TypeError no line X porque Y"

---

## üìû PR√ìXIMO PASSO

1. Copie o **Contexto** l√° em cima
2. V√° ao Antigravity
3. Cole contexto + **Prompt 1 (Auth0)**
4. Deixe o Gemini gerar
5. Revise o c√≥digo
6. Teste localmente
7. Pr√≥ximo prompt!

Boa sorte! üöÄ
